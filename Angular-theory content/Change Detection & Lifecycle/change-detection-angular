1) What is change detection in angular ?

In Angular, Change Detection refers to the mechanism Angular uses to check and update the DOM whenever the application state (data, variables, objects) changes.

Put simply:
â¡ï¸ Itâ€™s Angularâ€™s way of keeping your UI in sync with your componentâ€™s data model.


2)  What triggers Change Detection?

-> Events (click, input, keyup, etc.)

-> Promises / Observables (async operations, API responses)

-> setTimeout / setInterval

-> Any code that Angular runs inside Zone.js

3) Change Detection Strategies in Angular.

Angular offers two strategies:

1. Default (CheckAlways)

-> Runs on all components in the tree whenever something triggers CD.

-> Even if data hasnâ€™t changed, Angular still checks the bindings.

-> Works fine for small apps, but can be inefficient in large apps.

2) OnPush (CheckOnce)

Runs CD only when:

 1. @Input reference changes

 2. An event originates inside the component

 3. markForCheck() is called manually

More performant, avoids unnecessary DOM checks.

âœ… Why itâ€™s important

 -> Keeps UI reactive (always reflects latest data).

 -> Understanding it helps optimize performance (using OnPush, trackBy, immutability, memoization, etc.).

Essential for debugging why your UI isnâ€™t updating as expected.


OnPush Change Detection (CD)
1ï¸âƒ£ What is OnPush?

ChangeDetectionStrategy.OnPush tells Angular:

â€œOnly check this component if:

An @Input reference changes, or

An event originates inside this component, or

You manually trigger CD with markForCheck() or detectChanges().â€

Angular does NOT check this component every cycle like default CD.


2) What is Memoization and Immutability

ğŸ”¹ Memoization

Definition:

Memoization is an optimization technique where the result of a function is cached based on its inputs. If the same inputs are passed again, the cached result is returned instead of recalculating.

Why it matters in Angular:

Angular templates may call the same function multiple times during change detection.

Without memoization, expensive calculations or filtering logic would re-run unnecessarily.

Memoization ensures performance by avoiding recomputation.

Example

// Expensive function without memoization
getFilteredList(list: string[]) {
  console.log("Recalculated...");
  return list.filter(item => item.startsWith("A"));
}

// With memoization
private cache = new Map<string[], string[]>();

getFilteredList(list: string[]) {
  if (!this.cache.has(list)) {
    console.log("Recalculated...");
    this.cache.set(list, list.filter(item => item.startsWith("A")));
  }
  return this.cache.get(list)!;
}


ğŸ”¹ Immutability

Definition: Data should not be mutated directly (changing an array/object in place). Instead, create a new copy with changes.

Why it matters in Angular:

Angularâ€™s default change detection checks object references (shallow check).

If you mutate the object (e.g., push() in an array), Angular may not detect changes in OnPush strategy.

With immutability, new references are created â†’ Angular detects changes automatically.

// âŒ Mutating (may not trigger OnPush detection)
this.items.push("new item");

// âœ… Immutable update
this.items = [...this.items, "new item"];

ğŸ‘‰ In short:

Memoization = optimize repeated calculations.

Immutability = ensure change detection works efficiently.

2. Detach/Reattach Change Detection (ChangeDetectorRef)

Angular normally runs change detection for the whole component tree after every event (click, HTTP, timer, etc.).

Sometimes, you donâ€™t need Angular to check a component on every cycle â†’ you can detach it.

ğŸ”¹ Methods

detach(): Stop Angular from running CD on this component.

reattach(): Resume CD when needed.

detectChanges(): Run CD manually for this component and children.

markForCheck(): Mark component to be checked in the next cycle (works with OnPush).


import { ChangeDetectorRef, Component } from '@angular/core';

@Component({
  selector: 'app-heavy',
  template: ` <div>{{ counter }}</div> `
})
export class HeavyComponent {
  counter = 0;

  constructor(private cd: ChangeDetectorRef) {
    this.cd.detach(); // Stop automatic CD
    setInterval(() => {
      this.counter++;
      if (this.counter % 5 === 0) {
        // Update UI every 5 steps
        this.cd.detectChanges();
      }
    }, 1000);
  }
}


3. Zone.js (and Zone-less Angular)

ğŸ”¹ What is Zone.js?

Zone.js is a library Angular uses internally to know when to run change detection.


ğŸ”¹ How Does it do it to detect that change detection needs to run ?

It patches async APIs like setTimeout, Promise, addEventListener, so Angular knows:

  ğŸ”¹ â€œSomething happened â†’ time to check the UI.â€

Example:

  setTimeout(() => {
  this.value = 10; 
  // Angular auto-runs CD because Zone.js patches setTimeout
});

ğŸ”¹ Why is Zone.js inmportant in angular ?

ğŸŒ The Problem Without Zone.js

In a browser, many things happen asynchronously:

 ğŸ”¹ setTimeout() fires after some time.

 ğŸ”¹Promise.then() runs when the promise resolves.

 ğŸ”¹ addEventListener('click', ...) triggers when the user clicks.

 ğŸ”¹ XHR / fetch completes when the server responds.

ğŸ‘‰ Normally, JavaScript itself doesnâ€™t notify Angular that something changed.
So if you just updated a variable in one of these async callbacks, Angularâ€™s UI would not automatically update, unless you manually told Angular:

this.changeDetectorRef.detectChanges();

That would be painful.

âš¡ What Zone.js Does

Zone.js patches all async APIs in the browser.

That means instead of directly running the native setTimeout / Promise.then, Zone.js wraps them.

Without Zone.js

ğŸ”¹ JS waits 1s â†’ callback runs â†’ counter increases.

ğŸ”¹ Angular has no idea â†’ UI doesnâ€™t update.

With Zone.js

ğŸ”¹ Zone.js intercepts setTimeout.

ğŸ”¹ When the callback finishes â†’ Zone.js tells Angular:

    â€œHey Angular, something async just happened. Run change detection now.â€

ğŸ”¹ Angular runs change detection â†’ sees counter changed â†’ updates UI. âœ…

ğŸ”„ The Flow

1) Async operation starts â†’ Zone.js wraps it.

2) Async operation finishes â†’ Zone.js gets notified.

3) Zone.js calls Angularâ€™s NgZone â†’ which triggers change detection cycle.

4) Angular updates the DOM if something changed.

Why This Matters

This is the magic that makes Angular apps feel reactive out-of-the-box:

ğŸ”¹ You donâ€™t call setState() like in React.

ğŸ”¹ You donâ€™t call scope.$apply() like in old AngularJS.

ğŸ”¹ You donâ€™t call detectChanges() manually (most of the time).

ğŸ‘‰ Thanks to Zone.js, you just update variables, and Angular ensures the UI reflects the changes.


Advanced Case â€“ Zone-less Angular

Angular 17+ introduced zone-less mode.

ğŸ”¹ Here, Angular does not rely on Zone.js.

ğŸ”¹ Instead, you need signals or manual CD triggers.

ğŸ”¹ Benefits: performance (no global patching), finer control.

What is NgZone?

ğŸ”¹ NgZone is an Angular service (class) that wraps Zone.js and manages change detection.

ğŸ”¹ Itâ€™s the â€œbridgeâ€ between Zone.js and Angularâ€™s Change Detection system.

How NgZone Works

1) App runs inside Angularâ€™s zone (called the NgZone).

2) When an async task finishes (timer, promise, eventâ€¦), Zone.js notifies NgZone.

3) NgZone triggers Angularâ€™s change detection cycle â†’ UI updates.

Example 2 â€“ Running Code Outside Angular Zone

Sometimes you want to run code without triggering CD every time (for performance).
Thatâ€™s where NgZone.runOutsideAngular() helps.

constructor(private ngZone: NgZone) {}

startTimer() {
  // Runs outside Angular â†’ no change detection spam
  this.ngZone.runOutsideAngular(() => {
    setInterval(() => {
      console.log('Tick...'); // Wonâ€™t trigger CD
    }, 1000);
  });
}


Key Methods of NgZone

ğŸ”¹ run() â†’ Enter Angular zone (trigger CD).

ğŸ”¹ runOutsideAngular() â†’ Exit Angular zone (skip CD).

Events:

ğŸ”¹ onStable â†’ Fires when Angular is stable (no pending async tasks).

ğŸ”¹ onUnstable â†’ Fires when a new async task starts.

ğŸ”¹ Zone-less Angular

Angular v16+ introduced zone-less mode (bootstrapApplication(..., { ngZone: 'noop' })).

In this mode, Angular doesnâ€™t use Zone.js â†’ you must trigger CD manually.

bootstrapApplication(AppComponent, {
  providers: [{ provide: NgZone, useValue: 'noop' }]
});

// Then use signals or ChangeDetectorRef to update manually

