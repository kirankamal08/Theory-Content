what is component's Lifecycle :- A component's lifecycle is the sequence of steps that happen between the component's creation and its destruction.
Each step represents a different part of Angular's process for rendering components and checking them for updates over time.

 They are implemented as methods on your component class.

 * For the purposes of understanding this lifecycle, you only need to know that Angular walks your application tree from top to bottom, checking template bindings for changes. The lifecycle hooks described run while Angular is doing this traversal. This traversal visits each component exactly once, so you should always avoid making further state changes in the middle of the process.


 The key line:

â€œThis traversal visits each component exactly once, so you should always avoid making further state changes in the middle of the process.â€

Letâ€™s break it down:

â€œVisits each component exactly onceâ€
Angular checks every component one time during a single change detection cycle.

â€œAvoid making further state changes in the middle of the processâ€
This means: donâ€™t modify component data while Angular is already running change detection.

Why? Because if you change data (for example, modify a property or emit an event) during this traversal, Angular would need to re-run change detection again â€” but itâ€™s already in the middle of checking everything once.
That could lead to infinite loops, ExpressionChangedAfterItHasBeenCheckedError, or other inconsistent UI states.

ngAfterViewChecked() {
  this.title = 'Updated title'; // âŒ Bad idea
}

Here, Angular is already in the middle of checking bindings.
If you change this.title now, youâ€™re altering state after Angular has already checked this component â€” itâ€™ll detect the mismatch and throw:


Lifecycle hooks:

component creation - Creation- constructor ->  Runs when Angular instantiates the component.

Change
Detection

-> ngOnInit - Runs once after Angular has initialized all the component's inputs.
-> ngOnChanges - Runs every time the component's inputs have changed.
-> ngDoCheck - Runs every time this component is checked for changes.
-> ngAfterContentInit - Runs once after the component's content has been initialized.
-> ngAfterContentChecked - Runs every time this component content has been checked for changes.
-> ngAfterViewInit -	Runs once after the component's view has been initialized.
-> ngAfterViewChecked - Runs every time the component's view has been checked for changes.


Destruction

-> ngOnDestroy - Runs once before the component is destroyed.


Important: changing an @Input() causes many lifecycle hooks to fire. They are as:-

âš¡ IMPORTANT
ğŸ‘‰ Only initialization hooks run once:

ngOnInit

ngAfterContentInit

ngAfterViewInit

These should not run again when the input changes.

But check hooks run every time:

ngOnChanges

ngDoCheck

ngAfterContentChecked

ngAfterViewChecked

These run on every change detection cycle.

Changing an input triggers a change detection cycle â†’ so these hooks fire again.

âœ… These hooks run every single time

These 3 hooks are part of Angularâ€™s change-detection loop:

1ï¸âƒ£ ngDoCheck

Angular checks the component for changes.

2ï¸âƒ£ ngAfterContentChecked

Angular checks any projected content (even if you donâ€™t use <ng-content>).

3ï¸âƒ£ ngAfterViewChecked

Angular checks the componentâ€™s own view (template + bindings).

These 3 fire on every change detection cycle, always in this order.


ğŸ¬ Timeline of All Hooks in the Right Order (Easy Version)
ğŸ”¥ Child component hooks run first:

ngOnChanges

ngOnInit

ngDoCheck

â™¨ï¸ Then projected content is inserted â†’ so these fire:

ngAfterContentInit

ngAfterContentChecked

ğŸ”· Then child view is created â†’ so these fire:

ngAfterViewInit

ngAfterViewChecked

ğŸ”¶ Then parent hooks run (with fully initialized children ready)

Same sequence for parent

* Why does the parent run LAST?

Because the parent template contains <app-child> â€”
and to render the parent template, the child must be READY.

Angular cannot compile the parent until ALL of this is done:

Child class created

Child inputs resolved

Projected content placed

Child view initialized

Only then can the parent become stable.

Q: When a parent compiles, why do child hooks run first?

â¡ Because the parent cannot finish rendering until the child is fully initialized.
Angular resolves children â†’ then parent.

Q: Why ngAfterContentInit comes before ngAfterViewInit?

â¡ Because Angular inserts projected content BEFORE it builds the childâ€™s own view.

ContentInit = projected content ready

ViewInit = childâ€™s own DOM ready


EventEmitter - A very important concept in angular for child  =>  parent communication:

In Angular:

Child â†’ Parent communication uses EventEmitter

Parent â†’ Child communication uses @Input()

So EventEmitter is how the child sends data or notifies the parent that something happened.

âœ… 2. The Syntax at a Glance

Child Component

@Output() sendData = new EventEmitter<string>();

sendToParent() {
  this.sendData.emit('Hello from child!');
}

Parent Component

<app-child (sendData)="onChildEvent($event)"></app-child>

Parent TS

onChildEvent(data: string) {
  console.log(data); // 'Hello from child!'
}

EventEmitter is a lightweight observable inside the child, and Angular automatically subscribes to it when the parent uses (eventName)="".
When the child .emit()s, Angular sends the value into the parentâ€™s handler and runs change detection.

Q:- What is template reference varibale in angular ?

A Template Reference Variable in Angular is a way to get a reference to a DOM element or Angular component directly inside your template.
You define it using the #variableName syntax.

What It Is

A template reference variable gives you access to:

A DOM element

A component instance

A directive instance

An ng-template

â€¦from within the template.

Example:

<input #myInput type="text" />
<button (click)="showValue(myInput.value)">Show Value</button>
Here:

#myInput is the template reference variable.

It refers to the <input> element.

We can access its properties (like .value) directly.

Why Itâ€™s Useful

You can use template reference variables for:

âœ” 1. Accessing DOM elements
<input #username />
<button (click)="save(username.value)">Save</button>

âœ” 2. Accessing child components
<app-child #childComp></app-child>

<button (click)="childComp.someMethod()">
  Call Child Method
</button>

âœ” 3. Accessing directives
<div #ngIfDirective="ngIf" *ngIf="isVisible">
  Content
</div>

âœ” 4. Using Template-driven Forms
<input #name="ngModel" [(ngModel)]="fullName" />
<p>Valid: {{ name.valid }}</p>

âœ… When to Use Template Reference Variables

Use them when you need:

Quick access to view elements (instead of using ViewChild).

To read the value from inputs/textareas.

To trigger methods on a child component.

To reference a template or directive.

ğŸš« When NOT to Use Them

Avoid using them when:

You need the value inside TypeScript logic a lot â†’ use @ViewChild.

You need the reference before view initialization â†’ also @ViewChild.

âœ… Template Reference Variable vs @ViewChild

Both are used to get access to DOM elements, components, or directives â€”
BUT they work differently, have different scopes, and are used in different situations.

ğŸ”¶ 1. Template Reference Variable (TRV)

Syntax: #variableName

âœ” Works only in the template

You can use the reference only inside the HTML template, not in TypeScript.

âœ” Good for quick access

If you only need access directly in the template (e.g., reading an input value), TRVs are simple.

âœ” Does NOT interact with component class logic directly

No access inside .ts file.

Example:
<input #myInput />
<button (click)="log(myInput.value)">Log Value</button>

ğŸ”· 2. @ViewChild

Used in the component class, not inside the template.

âœ” Gives you access INSIDE the TypeScript component

You can call methods, read properties, change UI, etc.

âœ” Runs after view initialization

You can access it in:

ngAfterViewInit()

or with { static: true }, in ngOnInit()

âœ” Good for complex or reusable logic
Example:
@ViewChild('myInput') myInput!: ElementRef;

ngAfterViewInit() {
  console.log(this.myInput.nativeElement.value);
}


And your template:

<input #myInput />


Q :- What is thw difference between @ContentChild and @ContentChildren ?

They are Angular decorators used to access projected content â€”
i.e., content passed between <ng-content></ng-content> tags from a parent component into a child component.

These are NOT for accessing the componentâ€™s own template â€” thatâ€™s what ViewChild / ViewChildren are for.

ğŸ”· 1. @ContentChild
âœ” Gets a single projected element

It returns the first matching element, directive, or component inside <ng-content>.

âœ” Use when you expect one element.
Example:
Parent:
<app-child>
  <p #projectedPara>Projected Paragraph</p>
</app-child>

Child:
@ContentChild('projectedPara') para!: ElementRef;

ngAfterContentInit() {
  console.log(this.para.nativeElement.textContent);
}


ğŸ‘‰ Finds one element.


ğŸ”¶ 2. @ContentChildren
âœ” Gets multiple projected elements

Returns a QueryList (like an array) of ALL matching projected elements.

âœ” Use when you expect multiple child nodes.
Parent:
<app-child>
  <p #items>Item 1</p>
  <p #items>Item 2</p>
  <p #items>Item 3</p>
</app-child>

Child:
@ContentChildren('items') items!: QueryList<ElementRef>;

ngAfterContentInit() {
  this.items.forEach(item => {
    console.log(item.nativeElement.textContent);
  });
}


ğŸ‘‰ Finds all 3 paragraphs.


ğŸ”· 1. @ViewChild
âœ” Gets a single element, component, or directive

Returns the first matching element inside the componentâ€™s own template.

âœ” You use it when you need only one reference.
âœ” Runs after view initialization (ngAfterViewInit())


âœ… Example:
Template (child component or same component):
<h2 #title>Heading</h2>

Component:
@ViewChild('title') title!: ElementRef;

ngAfterViewInit() {
  console.log(this.title.nativeElement.textContent);
}


ğŸ‘‰ You get 1 element.


ğŸ”· 2. @ViewChildren
âœ” Gets multiple elements

Returns a QueryList of ALL matching elements.

âœ” You use it when you expect more than one.
âœ… Example:
Template:
<p #item>Item 1</p>
<p #item>Item 2</p>
<p #item>Item 3</p>

Component:
@ViewChildren('item') items!: QueryList<ElementRef>;

ngAfterViewInit() {
  this.items.forEach(i => console.log(i.nativeElement.textContent));
}


ğŸ‘‰ You get all 3 items.












