Understanding callbacks is essential before you truly â€œgetâ€ Promises and async/await, because those newer features were built to solve the pain of callbacks.
Ques -> What are callbacks ?

A callback is simply a function passed as an argument to another function, which is then called later (or â€œcalled backâ€) once some task is done.

function greet(name, callback) {
  console.log("Hi " + name);
  callback(); // calling the callback function
}

function sayBye() {
  console.log("Goodbye!");
}

greet("Alice", sayBye);


Output:

Hi Alice
Goodbye!

âš™ï¸ 2. Why Callbacks Exist

JavaScript is single-threaded â€” only one piece of code executes at a time.
But it must also handle tasks like:

Waiting for data from an API

Reading files

Setting timers

If these blocked the main thread, the browser would freeze.

ðŸ‘‰ So instead of blocking, JS delegates the task (e.g., to Web APIs) and uses a callback to handle the result later.

ðŸ•’ 3. Example: Asynchronous Callback

console.log("1: Start");

setTimeout(() => {
  console.log("2: Callback executed");
}, 2000);

console.log("3: End");

Output:

1: Start
3: End
2: Callback executed

Why?

JS starts setTimeout, passes the timer to the browser API.

JS continues executing the rest (non-blocking).

After 2 seconds, the browser pushes the callback into the callback queue.

The event loop checks when the call stack is empty, then executes that callback.

ðŸ•¸ï¸ 5. Callback Hell


When many async operations depend on each other, callbacks get nested, which becomes messy:

getUser(function(user) {
  getPosts(user.id, function(posts) {
    getComments(posts[0].id, function(comments) {
      console.log(comments);
    });
  });
});

This is called callback hell or the pyramid of doom.


Hard to read âŒ
Hard to debug âŒ
Hard to handle errors âŒ


âš¡ 6. How Promises Solved Callback Hell

Promises made asynchronous flow flat instead of nested.


getUser()
  .then(user => getPosts(user.id))
  .then(posts => getComments(posts[0].id))
  .then(comments => console.log(comments))
  .catch(error => console.error(error));

Now itâ€™s linear and cleaner.

There are some methods of the promises that are important to know these are:

Que: What is the difference between Promise.all, Promise.allSettled, Promise.any, and Promise.race?

Ans:These four methods (Promise.all, Promise.allSettled, Promise.any, and Promise.race) are part of the Promise combinators in JavaScript.
They allow us to run multiple promises in parallel and then handle their collective results in different ways.




And async/await is just syntactic sugar on top of Promises, which makes it look even more synchronous:

async function showComments() {
  try {
    const user = await getUser();
    const posts = await getPosts(user.id);
    const comments = await getComments(posts[0].id);
    console.log(comments);
  } catch (error) {
    console.error(error);
  }
}


Before async/await, JavaScript used callbacks and then Promises for handling asynchronous code.

exmaple :

fetchData()
  .then(data => process(data))
  .then(result => display(result))
  .catch(error => console.error(error));


-> This works, but when logic becomes complex, chaining .then() repeatedly can still be hard to read.

-> The Solution: async and await

They are syntactic sugar over Promises that make asynchronous code look synchronous and easier to read.

ðŸ§© The async keyword

When you mark a function as async, JavaScript always returns a Promise from that function

async function greet() {
  return "Hello";
}

greet(); // returns a Promise
greet().then(msg => console.log(msg)); // "Hello"


Internall this works like this:

async function greet() {
  return "Hello";
}
// is equivalent to:
function greet() {
  return Promise.resolve("Hello");
}


ðŸ•’ The await keyword

You can only use await inside an async function.
It pauses the execution of that function until the awaited Promise settles (resolves or rejects).

async function fetchUser() {
  console.log("Fetching user...");
  const response = await fetch("https://api.example.com/user");
  const user = await response.json();
  console.log("User fetched:", user);
}
fetchUser();


What happens internally:

When await encounters a Promise, the function execution is paused.

The rest of the async function is queued in the microtask queue.

JavaScript continues running other code in the meantime.

Once the Promise is resolved, the async function resumes execution from where it left off.


=> Example: With and Without await:

Using Promises:

fetchUserData()
  .then(user => fetchPosts(user.id))
  .then(posts => console.log(posts))
  .catch(error => console.error(error));

Using async/await:

async function showPosts() {
  try {
    const user = await fetchUserData();
    const posts = await fetchPosts(user.id);
    console.log(posts);
  } catch (error) {
    console.error(error);
  }
}
showPosts();

Benefits of async / await:

âœ… Easier to read
âœ… Fewer .then() chains
âœ… Error handling with try...catch


Memory and Execution Flow (Deep Dive)

async function example() {
  console.log("A");
  await Promise.resolve();
  console.log("B");
}
example();
console.log("C");

Step-by-step:

example() is called â†’ new execution context created â†’ logs "A".

At await Promise.resolve(), the promise resolves immediately, but the continuation (console.log("B")) is queued in the microtask queue.

The function pauses and returns control to the main thread.

"C" logs next because the main thread continues.

The microtask (console.log("B")) then runs after all synchronous code.

Output:

A
C
B

Error Handling

We can use try...catch inside async functions to handle Promise rejections:

async function getData() {
  try {
    const response = await fetch("wrong-url");
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error("Error:", error.message);
  }
}

If you didnâ€™t use try...catch, you could still catch it like this:

getData().catch(error => console.error(error));


Running Promises in Parallel

await waits sequentially, so if tasks are independent, itâ€™s better to run them in parallel using Promise.all().

Sequential (slower):

const a = await taskA();
const b = await taskB();

Parallel (faster):

const [a, b] = await Promise.all([taskA(), taskB()]);




